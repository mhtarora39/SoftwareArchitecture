// Using C++14 (gcc-5 5.1.1) 

#include "spoj.h"
#include <bits/stdc++.h>

using namespace std;

class ResultStruct {
public:
    bool   result;
    float  score;
    string message;
};

string read_whole_file_into_string(FILE * f) {

	char * buffer = '\0';
	int length;
	
	if (f) {
		fseek (f, 0, SEEK_END);
		length = (int) ftell (f);
		fseek (f, 0, SEEK_SET);
		buffer = (char *) malloc (length + 1);
		if (buffer) {
			fread (buffer, 1, length, f);
			buffer[length] = '\0';
		}
	}
	if (buffer) {
		return string(buffer);
	}
	return "";
}

// ------------------------- START -------------------------

#include<unordered_set>

unordered_set<string> my_brackets;

void find_brackets(int opening, int closing, int n, string s)
{
    if (closing == n)
    {
        my_brackets.insert(s);
        return;
    }
    if (opening < n)
    {
        find_brackets(opening + 1, closing, n, s + '(');        
    }
    if (opening > closing)
    {
        find_brackets(opening, closing + 1, n, s + ')');        
    }
}

void run_custom_checker(stringstream &input_file, stringstream &expected_output_file, stringstream &output_file, 
	ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    r_obj.result = true;
    r_obj.score = 1.0f;
    r_obj.message = "Success";
    

    int n;
    input_file >> n;
    find_brackets(0, 0, n, "");                                         // Find all the brackets.
    
    
    string s;
    /* 
    Compare output. Line by line scan the output of user and see if that string matches any of the well 
    formed bracket generated by us or not. If not then return wrong answer. If yes then remove that from
    my_brackets. 
    */
    while (output_file >> s)                                       
    {
        auto it = my_brackets.find(s);
        if (it == my_brackets.end())
        {
            r_obj.result = false;
            r_obj.score = 0.0f;
            r_obj.message = "Wrong answer!";
            return;
        }
        my_brackets.erase(it);
    }
    // If there are some brackets that user did not generate then return wrong answer. 
    if (my_brackets.size())
    {
        r_obj.result = false;
        r_obj.score = 0.0f;
        r_obj.message = "Wrong answer!";
    }
}
// End of BODY

// ------------------------- STOP -------------------------

int main(void) {
	spoj_init();

	string whole_input = read_whole_file_into_string(spoj_p_in);
	string whole_expected_output = read_whole_file_into_string(spoj_p_out);
	string whole_output = read_whole_file_into_string(spoj_t_out);

	cerr << "Input length: " << whole_input.length() << endl;
	// cerr << "Input:" << endl;
	// cerr << whole_input << endl;

	cerr << "Expected output length: " << whole_expected_output.length() << endl;
	// cerr << "Expected output:" << endl;
	// cerr << whole_expected_output << endl;

	cerr << "Output length: " << whole_output.length() << endl;
	// cerr << "Output:" << endl;
	// cerr << whole_output << endl;
	
    ResultStruct r_obj;
    r_obj.result = false;
    r_obj.score = 0.0f;
    r_obj.message = "Uninitialized";

    stringstream input_file(whole_input);
    stringstream expected_output_file(whole_expected_output);
    stringstream output_file(whole_output);


    run_custom_checker(input_file, expected_output_file, output_file, r_obj);
    if (r_obj.result) {
    	return SPOJ_RV_POSITIVE;
    }

	return SPOJ_RV_NEGATIVE;
}
